#include<iostream>
#include<array>
#include <vector>
//using namespace std;
using std::cin;
using std::cout;
using std::endl;

#define tab "\t"
#define delimiter "\n------------------------------------------\n"	

//#define STL_ARRAY
#define STL_VECTOR

template<typename T> void vector_info(const std::vector<T>& vec);


	void main()
{
	setlocale(LC_ALL, "");
	//cout << "Hello STL" << endl;

#ifdef STL_ARRAY
	// Array - это контейнер который хранит данные в виде статического массива, при создании array кроме типа хранимых значений так же обязательно нужно указать колличество хранимых значений.

	const int N = 5;
	std::array<int, N>arr = {3,5,8,13,21};
	for (int i = 0; i < arr.size(); i++)
	{
		cout << arr[i] << tab;
	}
	cout << endl;
#endif // STL_ARRAY
#ifdef STL_VECTOR

	std::vector<int>vec = { 0,1,1,2,3,5,8,13,21,34 }; // MaxSize: 536870911  1073741823
	for (int i = 0; i < vec.size(); i++)
	{
		cout << vec[i] << tab;
	}
	cout << endl;
	vector_info(vec);
	vec.push_back(55);
	for (int i = 0; i < vec.size(); i++)
	{
		cout << vec.at(i) << tab;
	}
	cout << endl;

	vector_info(vec);
	vec.reserve(24); // резервирует память до заданной вместительности. 
	                 // если текущая вместительность больше заданной, то ничего не происходит
	                 // резервирует столько вместительности сколько мы хотим, если хотим больше чем есть на данный момент
	vector_info(vec);
	vec.shrink_to_fit(); // урезает вместительность до фактического размера vectora (size)
	                     // это можно сделать в целях экономии памяти, если мы уверены что в вектор больше ничего не будет добавляться. https://legacy.cplusplus.com/reference/vector/vector/
	vector_info(vec);

	vec.resize(8); // задает фактический размер вектора. При уменшении теряются значения в конце Вектора!!!
	for (std::vector<int>::iterator it = vec.begin(); it != vec.end(); ++it)
	{
		cout << *it << tab;
	}
	cout << endl;
	vector_info(vec);
	vec.resize(14);
	for (int i : vec)cout << i << tab; cout << endl;
	vector_info(vec);

	
//https://legacy.cplusplus.com/reference/vector/vector/insert/ //Iterator - указатель при помощи которого мы получаем доступ к элементам структуры данных:// можно перебирать элементы структуры данных/
// массив - непрерывная область памяти. [] - возвращает значение по индексу. Находится значение. Как получить адрес начала вектора, как получить адрес начала любого контейнера - есть метод begin
	
	int index;
	int count;
	int value;
	/*cout << "Введите индекс добавляемого элемента: "; cin >> index;
	cout << "Введите количество добавляемых элементов: "; cin >> count;
	cout << "Введите значение добавляемого элемента: "; cin >> value;*/

	//vec.insert(vec.begin()+ index, value);
	//vec.insert(vec.begin() + index, count, value);

	//for (int i : vec)cout << i << tab; cout << endl;

#endif // STL_VECTOR




}
	template<typename T> void vector_info(const std::vector<T>& vec)
	{
		cout << "Size: " << vec.size() << endl;
		cout << "Capacity: " << vec.capacity() << endl;
		cout << "MaxSize: " << vec.max_size() << endl;
	}

	//Видео 42 

//https://legacy.cplusplus.com/reference/stl/

	//   STL - standatd Template Libraty - стандартная шаблонная библиотека. 
	// Представляет собой набор контейнеров итераторов, алгоритмов, алокаторов, предикатов и функциональных объектов. 
	 // Абсолютно все сущности в STL являются шаблонными, т.е могут работать с любыми типами данных
	     // Ключевым понятием STL - является контейнер. Container - это объек, который организует хранение других объектов в памяти. 
	                   // Контейнеры бывают:
	  // 1.линейные(sequence containers),
	  // 2.ассоциативные(Associative containers), 
	  // 3.Контейнер адаптеры(Adaptor container),
	  // 4.Ассоциативные контейнеры(Unordered associative containers: 

	// 1 Линейные контейнеры - хранят элементы последовательно один за другим либо в непрерывной области памяти либо в виде списков. К ним относятся: array, vector, deque, forward_list, list;
	// 2 Ассоциативные контейнеры - хранят данные в виде бинарного дерева поиска. К ним относятся: map, set,multimap,multiset; 
	//3 Контейнер адаптерс: реализует некоторые распространенныеа модели памяти такие как FIFO ,LIFO.... как правило построены на базе других контейнерах. К контейнерам адаптерам относятся stack  - реализует (LIFO - Last In - First Out);
	// queue - (FIFO - First In - First Out); 
	// priority_queue-  приоритетная очередь
	//  4 Unordered associative containers: - или несортированные ассоциативные контейнеры. 
	//unordered_map; unordered_multimap;
	//unordered_set; unordered_multiset;

	// У каждого контейнера есть свой набор итераторов в зависимости от того какую структуру данных использует контейнер. 

	// Каждый контейнер объявлен в своем заголовочном файле и что бы использовать како	 либо контейнер нужно подключить соответсвующий заголовочный файл. 

	// Алгоритмы  это самые обычные функции которые выполняют некие стандартные действия над контейнером, такие как сортировака, поиск значения и сравнения. Большинство алгоритмов работают со всеми контейнерами но к некоторым контейнерам некоторые алгоритмы не применимы - например: деревья не сортируются поскольку они всегда отсортированы. 
	// Все алгоритмы обьявлены в заголовочном файле алгоритмы <algorithm> 
	// Алокатор (Allocator) - это функция которая выделяет память. 
	// Predicate -  это функция которая возвращает true либо folse. 
	// Функциональный обьект - это обьект который существует исключительно для того что бы вызывать для него функции. 


	// Array - это контейнер который хранит данные в виде статического массива, при создании array кроме типа хранимых значений так же обязательно нужно указать колличество хранимых значений.  


	//Vector - это контейнер хранит данные в виде динамического массива при создании вектора обязательно задают тип хранимых элементов.

	// 42 2.03

	// На базе односвязного списка создать Stack;
	//На базе двусвязного списка создать Queue;
	// *Выяснить в чем разница мужду оператором [] и методом at();


	           // Vector - это единственный контейнер у которого есть capacity(вместительность) потаму что это единственный контейнер который резервирует память для будущего использования. т.е vector пости всегда резервирует больше памяти чем требуется для хранения элементов, именно это свойство вектора и дает возможность максимально быстро добавлять значения в конец массива но если при добавлении элемента обнаруживается что зарезервированная память закончилась vector переопределяет память и выделяет больше памяти чем требуется для хранени его элементов. Благодаря резервированию такая дорогостоящая процедура как переопределение памяти выполняется на столько редеко на сколько это возможно. 

	// Для работы с capacity используются следующие методы: reserve();

	//43 ->

	//Оператор []: Не выполняют проверку границ. Если вы попытаетесь получить доступ к элементу, который находится за пределами контейнера, это приведет к непредвиденному поведению.

 //Метод at(): Выполняет проверку границ. Если вы попытаетесь получить доступ к элементу за пределами контейнера, он бросит исключение std::out_of_range.

	//	 Оператор []: возвращает ссылку не элемент контейнера. Если контейнеа содержит элементы, вы можете использовать оператор []для его изменения.

	//	Метод at(): Также возвращает ссылку на элемент контейнера, но его основной фокус - на безопасном доступе с проверкой границ.

	//	Оператор[]: Обычно доступен в контейнерах, которые поддерживают индексирование , таких как std::vector,std::array и std::map(для std::map, это возвращает ссылку на элемент или создает его, если его нет).

	//	Метод at(): Доступен в контейнерах, которые реализуют его, таких как std::vector, std::deque,std::array, но не доступен в std::map или std::unordered_map(в этих контейнерах используйте operator[]для доступа).

	//	В общем, если вы хотите гарантированную безопасность при доступе к элементам, лучше использовать метод at(). Если вы уверены, что индексы находятся в допустимом диапазоне и хотите немного повысить производительность, можно использовать оператор [].
		